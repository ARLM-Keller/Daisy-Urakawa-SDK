<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><title>Additional API-Doc Comments</title></head><body><h1 id="AdditionalAPI-DocComments">Additional API-Doc Comments</h1><h2 id="RootUri">RootUri</h2><p>
The Presentation.RootUri property is an absolute path against which any relative paths specified for that Presentation in the XUK document will be resolved.
</p><p>
If Presentation.RootUri is not set explicitly (i.e. programmatically), the property defaults to the current application folder given by System.IO.Directory.GetCurrentDirectory().
</p><p>
However, when reading a Presentation from XUK (i.e. XukIn() method), a non-existing or empty "rootUri" attribute will result in Presentation.RootUri becoming the URI of the XUK file itself (unless the XML data comes from a memory stream, in which case the default is the current application directory again).
</p><p>
For example, the DataProviders (i.e. audio data sources, actual file locations) for one given Presentation are all managed inside a single folder of which the location is [Presentation.RootUri + DataProviderManager.DataFileDirectory]. Please note that Presentation.RootUri can either be a folder or a file, as the System.Uri class resolves paths transparently in both cases.
</p><h2 id="OpenSaveXuk">Open/SaveXuk()</h2><p>
The Open/SaveXukActions are not meant to be used to copy entire project data from one place to another. They are just the underlying mechanism used by the Project.Open/SaveXUK() methods, with support for progress report (ProgressAction, ProgressEvents). They basically take care of de/serializing the XUK data itself, without handling associated media data. The data folder [Presentation.RootUri + DataProviderManager.DataFileDirectory] should be moved manually to the new location. All paths in the data model are resolved dynamically (no hard-coded values), so unless there are open Streams while performing a "save as" operation (an obvious mistake), the model should not become corrupted. Something to keep in mind: the undo-redo stacks may contain active references to managed media data, which will be preserved in XUK which is why it needs to be copied across in the data directory.
</p><h2 id="Export">Export</h2><p>
TreeNode.Export(Presentation) takes care of cloning fragments of the tree to be used in the specified destination Presentation. It succeeds only if the source and destination Presentation are compatible (same Factories, etc.).
</p><h2 id="PublishManagedAudioVisitor">PublishManagedAudioVisitor</h2><p>
PublishManagedAudioVisitor does more than just copying data, it creates a new type of XUK document with ExternalMedia instead of ManagedMedia. This is therefore useful only at the publishing stage, as it looses important authoring-time information (the active Managed media data of the session). The unit-tests in urakawa.publish.PublishManagedAudioVisitorTests, in particular the PublishTest(Presentation) static function, demonstrate how to generate a single audio file per level-1 (direct TreeNode children of Presentation.RootNode). This can be adapted to meet other needs.
</p><h2 id="WavAudioMediaData.forceSingleDataProvider">WavAudioMediaData.forceSingleDataProvider()</h2><p>
Makes one audio file (i.e. WavClip/FileDataProvider) per MediaData (i.e. per ManagedMedia, but not necessarily per TreeNode).
</p><h2 id="WavAudioMediaData.copy">WavAudioMediaData.copy()</h2><p>
The copy() method was unnecessarily duplicating FileDataProviders (actual files):
</p><ol><li>the copy() <a xmlns="" href="http://daisy-trac.cvsdude.com/urakawa-sdk/browser/trunk/csharp/core/media/data/audio/codec/WavAudioMediaData.cs?rev=1217#L332">method</a> in WavAudioMediaData duplicates ("clones") the WavClips.
</li><li>the copy() <a xmlns="" href="http://daisy-trac.cvsdude.com/urakawa-sdk/browser/trunk/csharp/core/media/data/audio/codec/WavAudioMediaData.cs?rev=1217#L80">method</a> in WavClip creates a copy of the DataProvider (this is now removed).
</li><li>the copy() <a xmlns="" href="http://daisy-trac.cvsdude.com/urakawa-sdk/browser/trunk/csharp/core/media/data/FileDataProvider.cs?rev=1215#L312">method</a> in FileDataProvider delegates the work to the DataProviderManager.
</li><li>the AppendDataToProvider() <a xmlns="" href="http://daisy-trac.cvsdude.com/urakawa-sdk/browser/trunk/csharp/core/media/data/DataProviderManager.cs?rev=1217#L53">method</a> in DataProviderManager actually copies the bytes across the binary audio streams.
</li></ol><p>
This has been fixed so that step (2) has been removed, so in essence the FileDataProviders are now shared across several WavAudioMediaData. All the operations in WavAudioMediaData (insert, append, merge, etc.) modify the underlying (private) WavClip data structure, in a way that does not create conflicts between shared DataProviders (i.e. physical files). In other words, once a FileDataProvider is created (and potentially shared amongst several WavClips, and therefore amongst different WavAudioMediaData), the file content is never touched. The presentation never becomes corrupted.
</p><h2 id="Cleanup">Cleanup</h2><p>
The "cleanup" mechanism <a xmlns="" href="http://daisy-trac.cvsdude.com/urakawa-sdk/browser/trunk/csharp/core/media/data/FileDataProviderManager.cs?rev=1193#L542">implemented</a> in FileDataProviderManager::removeUnusedDataProviders(true) actually deletes files, making it impossible to recover the data (i.e. undo is impossible).
</p><p>
The "cleanup" mechanism <a xmlns="" href="http://daisy-trac.cvsdude.com/urakawa-sdk/browser/trunk/csharp/core/Presentation.cs?rev=1193#L286">implemented</a> in Presentation::cleanup() checks the undo/redo stack as well as making one audio file per used MediaData (i.e. WavAudioMediaData.forceSingleDataProvider()):
</p><h2 id="ProgressHandlerProgressActionProgressEvent">ProgressHandler, ProgressAction, ProgressEvent</h2><p>
The Progress feature was <a xmlns="" href="http://daisy-trac.cvsdude.com/urakawa-sdk/changeset/1193">introduced</a> to facilitate displaying a progress report (i.e. progress bar UI widget) during lengthy operations within the SDK. It is currently only implemented for the XukIn/Out() methods. This is largely insufficient, as the XML (de)serialization is actually quite fast even for very large XUK files. We need to make that feature available for file copy methods as well (manipulation of binary streams).
</p></body></html>